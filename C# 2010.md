### Gute SOftware, Schlechte Software

VOr gut zehn Jahren hatte ich den ersten Kontakt mit einem damals neuartigen Online-CMS (Content Management System). Es war kurz vorher bei einem Unternehmen eingeführt worden, in dem ich als Leiter der Online-Entwicklung eingestellt wurde. Es stammte von einem renommierten Unternehmen, hatte einen klangvollen Namen, und die Verkäufer konnten mit einer langen Referenzliste worden. Meine Aufgabe sollte es sein, auf Basis dieses Systems zahlreiche neue ONline-Auftritte zu entwickeln, gemeinsam mit eigenne und freiberuflichen Mitarbeitern.

Für den Einkäufer dieses CMS war das eine sichere Sache, sollte man meinnen. IM praktischen Einsatz wurden sehr bald die Mängel deutlich, und die waren gravierend: Das System lahmte selbst auf den schnellsten Servern, es war instabil, ganz und gar kontra-intuitiv zu bedienen, schwer zu administrieren und mit allerlei eigenen, proprietären Lösungen für ganz alltägliche Probleme ausgesstattet.

Hotline, Entwicklung und Geschäftsleitung des Softwareherstellers hatten das Problem längst ausgemacht: Der Kunde sei das Problem, das System liefe schließlich in großen Installationen zuverlässig und, soweit man wisse, problemlos. Das wollte ich nicht recht glauben, und so begann ich, mit diesen Referenzkunden zu telefonieren und sie zu besuchen. Und wie es zu erwarten war, glichen sich die Probleme. Viele UNternehmen berichteten über genau die Schwierigkeiten, die auch wir hatten.

Und so war das Ende unausweichlich: Nach einigen erfolglosen Resleases tauschten wir das System gegen ein CMS aus, das aufff offenen Standards wir PHP und MySQL aufbaute, kaum ein Zwanzigstel so teuer und wenigstens zehnmal so schnell war. Dieses System läuft auch heute noch.

Seitdem habe ich mich in zahlreichen Projekten immer wieder gefragt: Was macht gute Software aus, und was unterscheidet sie von schlechter Software? Warum lässt sich die eine Software elegant und preiswer erweitern, während sich andere Programme vehement gegen jede Form der Anpassung sträuben? Warum gibt es Lösungen, mit denen sich flüssig arbeiten lässt, während bei anderen jeder Klick zum Geduldsspiel wird, und warum gibt es so viele gute Benutzeroberflächen, aber warum auch so viele schlechte? Wieso kann der Aufwand fürdas Customizing einen Brchteil des Kaufpreises ausmachen, aber auch leicht ein Mehrfaches, und warum müssen manche Softwareprodukte bei jedem neuen Release in großen Teilen neu geschrieben werden, während andere über viele Jahre hinweg scheinbar mühelos erweitert werden können?

#### Wege zur Lösung

Ich behaupte nicht, die Antwaort auf all diese Fragen zu kennen. Aber ich habe über die Jahre zahlreiche Muster entdeckt, Fallstricke, wenn Sie es so nennen möchten, aus den eigenen Projelkten heraus, aber vor allem in der Zusammenarbeit mit meinen Mitarbeitern, eexternen Programmierern, Auszubildenden und Consultants.  Aus meinen und ihren Erfahrungen ist dieses Buch entstanden. Es verfolgt 3 Ziele:

**Wissen erweitern**
Geradeich kleineren UNternehmne müssen Entwickler oft wahre Allrounder sein. Denn neben fundierten Fertigkeiten in verschiedenen Programmiersprachen benötigen Sie noch viele weitere Kenntnisse, beispielsweise in Fragen der Softwarearchitektur, im Softwaredesign, in ihrer Entwicklungsumgebung, in den verschiedensten eingesetzten Technologiesn, in Softwaretests, Projektmanagement und Datenbankentwurf.

NIch jeder Entwickler hat die Zeit, Lust oder Gelegenheit, sich durch viele Regalmeter Fachliteratur zu arbeiten. Dieses BUch macht den durchaus gewagten Versuch, die wichtigsten Bereiche der Softwareentwicklung in einem einzigen Werk zu behandeln, von der richtigen Architektur über die UMsetzung bis hin zur Softwarepflege nach deren Einführung. Damit ist es ein Buch für "Aufsteiger", also Entwichler, die dazulernen möchten und die über Bekanntes aus einem anderen BLickwinkel neu nachdenken wollen

**Problem vermeiden helfen**

In diese BUch finden SIe immer wieder Kästen mit dem Titel "Aus der Praxis". In diesen Kästen finden SIe das eine oder andere Problem, das ich inder Vergangenheit selbst erlebt habe, und meist einen Lösungsansatz dazu. Vielleicht erkennen SIe bisweilen Ihr eigenes Projekt darin wieder, dann betrachte ich SIe als Leidensgenossen, wenn Sie erlauben. Ansonsten täten Sie mir einen großen Gefallen, wenn Sie diese Problem vermeiden würden

Ich habe beim Schreiben bisweilen selbst gestaunt, wie viele Fehler mir während der Jahre unterlaufen sind. Viele wären leicht zu vermeiden gewesen, bei anderen lagen ihre Ursachen etwas tiefer

**Best Practices vermitteln**

Der Begriff *Best Practices* stammt eigentlich aus der Betribeswirtschaft und bezeichnet bewährte Verfahren, die sich für gleiche oder ähnliche Aufgabenstellungen eignen. *Entwurfsmuster* oder *Design Patterns* sind fertig Lösungen oder Lösungsschablonen für häufig widerkehrende Probleme in der Softwareentwichlung. SIe könne damit ebenfalls inm weiteren Sinne den Best Pracktices zugerechnet werden.

Myriaden von Problemen entstehen durch die falsche oder unzureichenede IMplementierung häufig wiederkehrender Aufgabenstellungen. Niht selten hat jeder Entwickler seine eigene Lösung entwickelt. Dabei sind viele dieser Aufgabenstellungen im Detail komplex, die Lösungen aber meist zu einfach,  wie das folgende Beispeil zeigt

´´´
    Um mit Services zu kommunizieren, die mit WCF (Windows COmmunication Foundation) entwickelt wurden, benötigt man einen Proxym, ein Objekt also, das die Kommunikation mit dem Service kapselt. In vielen Lehrbüchern findet man dazu Beispiele wie:
        MyServiceClient client = new MyServiceClient();
        client.Open();
        try
        {
            client.DoSomething();
        }
        catch (Exception ex)
        {
            MessageBox();
        }
        client.Close();
´´´

Dieses Beispeil funktioniert und ist daher in vielen Programmen verwirklicht. ES ist aber wenig praxistauglich, den Verbindungsabbrüche, Timeouts, SIcherheitsprobleme und einige andere aufgetretende Ausnahen verlangen nach jewielts speziellen Behandlungen. Das ist unverzichtbar für ein robustes und fehlertolerantes Programm.

IM Grunde genommen müsste sich nun jeder Entwickler in die Tiefen der WCF-Kommunikation begebenm, um selbst eine adäquate Lösung zu entwickeln, oder er greift auf das Client-Pattern in Kapitel 6, "Windows Communication FOundation", zurück.


# Das Fallbeispiel

An der einen oder anderen Stelle vewende ich ein Fallbeispeiel, gewissermaßen als Kontrastprogramm zu den allerorts beliebten "Hallo Welt!" Beispeielen. Herzlich willkommen also in der Welt der Kalimba Sunfood mb, dem Premium IMporteur für sonnenverwöhnte Früchte aus aller Welt mit Sitz in Hamburg.

Unsere Firma importiert Waren aus aller Welt und benötigt hierfür eine Enterprise Resource Planning Software zur Stererung aller betrieblichen Funktionen, also:
- Warenwirtschaft
- Kundenerwaltung
- Finanz und Rechnungswesen
- Verkauf und Marketing
- Controlling ung
- Personalwirtschaft

Es werden etwa 800 Mitarbeiter beschäftigt, die Hälfte am Stammsitz in Hamburg, die andere Hälfte verteilt auf mehrere Standorte weltweit. Kalimba Sunfood kauft die Früchte vor Ort ein, beispeielsweise Orangen aus Brasilien oder Mangos aus Indien, exportiert sie nach Deutschland und vertreibt sie dort an Großhändler und die Getränkeindustrie. Darüber hinaus betreibt die Gesellschaft einnen Onlineshop für Cocktail-Fruchtsäft, in dem Privatkunden direkt bestellen können.

Die beiden Niederlassungen in den USA und Indien sind bereitbandig an die Zentralle angeschlossen, ihre Mitarbeiter nutzen Rich-CLient-Anwendungen. Die Büros der Einkäufer sind schmalbandig ageschlossen, daher greifen die dortigen Mitarbeiter über das Internet auf Webanwendungen zu. Natürlich setzt die hausinterne Entwicklungsabteilung auf .NET als Kerntechnologie und dazu noch auf
- Winforms für die Rich-Client-Anwendungen
- ASP.NET für die Webanwendungen
- WCF für die serviceorientierte Mittelschicht
- WF für die Verarbeitung der Bestellungs-Workflows
- VS 2010 Premium als Entwicklungsumgebung und auf
- SQL server 2008 als Datenbanksystem
Das zu entwickelnde ERP-System nennt unsere Firma das Kalimba.ERP

# Architekturentwurf

EIn Kapitel üüber Softwarearchitektur in einem Praxis buch, passt das zusammen? Ja, wenn wir Softwarearchitektur als das verstehen, was sie ist - als notwendigee Grundlage für den Bau erfolgreicher Software

Architektur ist kein Selstzweck, und Architekturdiagramme sind nur selten etwas, für das derAuftraggeber bezahlen möchte. Der allseits bemühte Vergleich mit den Architekten im Bauwesen stellt klar: ohne Architekt kein Gebäude, ohne Softwarearchitekt kein Softwareprodukt. Ich meide solche Vergleiche jedoch, denn Bau und Softwarearchitekten haben nur wenig gemeinsam. Während es im Baugewerbe unzählige Regeln und Normen gibt, treffen wir in der SOftwareentwicklung, wenn überhaupt, auf Best Practices. Und wo sich die Bauvorhaben großteils ähneln, ist jede SOftware eine Einzelanfertigung. Mehr noch: Imgegensatz zum Bauarchitekten gibt es für Softwarearchitekten keine allgemein anerkannte und weitverbreitete Ausbildung, ja noch nicht einmal über deren Aufgaben besteht Einigkeit



Morgen zusammen, ich arbeite gerade an meiner Bachelorsarbeit. Ich wende mich an mein Professor und er slug mir vor, mit dem Entwurf und Implementierung zu beginnen. Jetzt versuche ich mein CAN protol zu schreiben und auf Arduino Portenta H7
zu implementieren.

Softwarearchitekten stehen nicht im Ruf Pragmatiker zu sein, und meist leisten sich nur große Projekte einen eigenen Architekten. Dabei kann auf eine gute Softwarearchitektur als Grundlage für moderne Software nicht verzichtet werden. Architektur findet immer statt. DIe frage ist nur: Ist sie das Ergebnis planvollen Handelns, vor der Implemnetierung, oder entsteht sie aus der Erfahrung einzelner Entwickler heraus, während der Entwicklung

Ich möchte IHnen in diesem Kapitel die Softwarearchitektur nähebringen, als eigenen Teilschritt innerhalb des Entwicklungsprozesses. Sie werden sehen: Softwararchitektur ist viel prakticher, als Sie vielleicht denken, und viele Fragestellungen wirken direkt auf die spätere Implementierung.

Dieses Kapitel handelt zwar von der Softwarearchitektur, dennoch ist die Grnzlinie zum Softwaredesign nicht scharf zu ziehen. Diese Kapitel verschmilzt daher sozusagen mit dem nächsten Kapitel zu einer EInheit. Mein wichtigstes Ziel ist, das Feld zu bestellen, auf dam Archtektur stattfindet und die richtigen Fragen zu formulieren, die dann zu den hoffentlich richtigen Antworten für Ihr Projekt führen.

# Einführung

In diesem Abschnitt werden wir Softwarearchitektur dingfest machen. Sie werden sehen, warum es sich lohnt, Zeit darauf zu verwenden, und Sie werden die Grundzüge guter Architektur kennenlernen

## Das Problem

Die Kalimba Sunfood Gmbd möchte ihr Angebot um eine Online-Bestellmöglichkeit für Einzelhändler erweitern. Alice, die Programmmanagerin, und Bob, der Entwicklungsleiter, treffen sich zu einer Besprechung:

Alice: Hi Bob, es  geht um das Konzept, das ich dir letzte Woche gemailt habe. Wie du weißt, findet in 2 Monaten die Food-Pro Messe in Barcelona statt, und wir möchten unser neues Vertriebskonzept für Einzelhändler vorstellen. Dafür benötigen wir einen Onlnie-Shop, den wir dort präsentieren können.

Bob: OK, dein Grobkonzept lässt aber viele Fragen offen. Wir identifizieren wir beispeilsweise unsere Kunden im Web, wie kommen die individuellen Verkaufskonditionen auf die Internetsetite, und wie läuft dann die Bestellabwicklung ab.

ALice: Aber das sind doch alles technische Details, dafür seid ihr ja in der Entwicklung zuständig. Für mich sind die fachlichen Aspekte wichtig, die ich im Konzept ja ausführlich beschrieben habe.

Bob: NIchts für ungit, aber fpr eine Umsetzung sind sieben Seiten nicht ausreichend. Es geht auch darum, wie wir diese neue Software in die bestehende Softwarelandschaft einbinden könne. Der neue Vetriebsweg is ja nicht eigenständig, viele Prozesse laufen auch außerhalb der Website, beispielsweise im Kalimba.ERP, und die Daten sollen doch zentral gespeichert werden, oder?

Alice: Von Datenbanken verstehe ich nichts, aber wenn wir die Software nicht zur Food-Pro vorstellen könne, dann verlieren wir Marktanteile-unsere Wettbewerber bieten solche Lösungen schon seit Jahren. Hier geht es um time-to-market, die Lösung muss unbedingt fertig werden, in Schönheit sterben können wir später auch noch.

Bob: Ween wir dir jetzt eine vermeintlich einfache Lösung bauen, dann wird uns die Pflege ein Vielfaches kosten, die Werbeabteilung hat keinen einheitlichen Blick mehr auf den Kunden, und viele Prozesse werden manuell ablaufen müssen.

ALice: Wenn wir keine einfache Lösung zur Messe haben, dann werden die Kosten viel höher sein. Kannst du nicht einfach einen Prototyp bauen? Wir wissen ja noch gar nicht, wir das neue Vertriebsmodell ankommt, und deswegen steht auch kaum Budget bereit. Wenn es funktioniert, dann bringen wir einfach eine Version 2 mit all den tollen Features, die ihr Programmierer euch wünscht

Es kommt wir es kommen muss: Zur Messe steht eine "Version 1" zur Verfügung, ein Provisorium, für dessen grundlegende Überarbeitung dann später Zeit und Geld fehlen. ABer was ist daran auszusetzen?

## ut Softwarearchitektur, schlechte SOftwarearchitecktur

Softwarearchitektur ist schwer zu greifen, weil ihre Aufgaben so vielschichtig sind. Dennoch gelingt es uns leicht, die Auswirkungen schlechter Architekturentscheidungen zu erkennen:

Merkmal                                 Auswirkung
- Komlexität:                        Lösungen erscheinen uns unbeherrschbar komplex, das Gesamtbild ist nicht erkennbar, die ersten Schritte zur Umsetzung sind unklar
- Kosten/Termintreue: Die Projektkosten laufen aus dem Ruder, der Zeitplan gerät ins Wankenaus. Die Lösung muss immer wieder umgebaut werden, da neu entwickelte Teile nicht zu den bereits vorhandenne Teilen passen
- Redundanz: Dieselben Aufgabenstellungen werden mehrfach gelöst, in unterschiedlichem Kontext und unterschiedlichen Modulen. Dennoch lassen sich diese Module aber nicht mehr in anderen Anwendungen wiederverwenden
- Performance: Das System ist zu langsam, die einzelnen Komponenten arbeiten nur unzureichend zusammen.
- Integration: Die einzelnen Module passen nicht so recht zusammen, sie enthalten oft Hilfskonstruktionen, damit sie überhaupt kompatibel sind und verlieren damit an Unabhängigkeit. Es gibt viele Schnittstellen, die alle recht unterschiedlich implementtiert sind.
- Wartbarkeit: Neue Anforderungen lassen sich nur umsetzen, wenn immer wieder große Teile der Software umgebaut werden. Nur wenige Mitarbeiter beherrschen daher die Implementierung neuer Funktionne
- Konfiguration: Anforderungen müssen programmiert werden, auch wenn eine Konfigurationsänderung eigentlich genügt hätte
- Dokumentation: Die Dokumentation ist schwer zu lesen, beschreibt viele Ausnahmen und lässt den inneren Zusammenhalt vermissen
- Pflegephase: Die Umsetzung neuer Anforderungen dauert lange, kostet viel und birgt ein hohes Risiko für neu auftretende Fehler
- Qualität: Anwender, Entwickler  und Tester bemängeln die Qualität der Software. Sie benimmt sich zunehmend unberechenbar, und der AUfwand für die Fehlersuche und Fehlerbehebung nimmt überproportional zu

 Natürlich liegen die Gründe für die obengenannten Probleme nicht ausschließlich in einer mangelhaften Architektur. Manchmal ist auch einfach nur die UMsetzung fehlerhaft, oder die Tests wurden nicht gewissenhaft genugt durchgeführt; dennoch sind die Symptome typisch, und einige davon finden sich sicher in einer Software wieder, wenn der Architektur nicht der nötige Stellenwert zukommt.

 ## Aufgaben

 Literatur und Wissenschaft bieten uns viele Definitionen des Begriffs Software architektur. Vielversprechender scheint mir allerdings die Frage zu sein: Womit beschäftigt sich SOftwarearchitektur? Wir könnten nun einfach sagen: Sie beschäftigt sich damit, die oben dargestellten Probleme zu vermeiden! Das wäre nicht verkehrt, aber ein wenig genauer:
 In der Softwwarearchitektur geht es darum.
 - Die Komponenten eines Softwaresystems zu identifizieren
 - diese in Beziehung zueinander zu bringen dund die Art dieser Beziehungen zu erkennen und zu beschreibung
 - die Konfiguration und deren Eigenschaften zu bestimmen
 - die INfrastruktur um diese Komponenten herum richtig auszuwählen und richtig anzuwenden, und
 - die einzelnen SOftwaresysteme so miteinander zu verbinden, dass ein funktionierendes Ganzes entsteht

 Oder anders ausgedrückt: Architektur macht Komplexität erst beherrschbar. Wichtigtes Hilfsmittel ist also die Analyse. Eine Aufgabe wird zerlegt und die KOmponenten den Zielen entsprechend angeordnet

 ## Anwendungstypen

 IN der praktischen Architektur ist es nicht ausreichend, Komponenten, Beziehungen und Schichten ausfindig zu machen bzw zu entwerfen, sondern es müssen Grundlagenentscheidungen getroffen werden. Hier verschwimmt die Grenze zum SOftwaredesign. Betrachten wir eine Anwendung, wie Lotus NOtes. Mit dieser können Daten auch lokal, ohne Zugriff auf einen Server, bearbeitet werden. Ein solche Software benötigt ein anderes Design, aber auch eine andere Architektur als eine reine Client/Server Lösung, in der ein Server immer zur Verfügung steht
 Es ist daher sinnvoll, einige Anwendungstypen zu definieren, wobei auch hier die Trennlinie nicht messerscharf zu ziehnen ist

 ### Mobile Anwendung

 Eine Anwendung dieser Kategorie läuft auf einem mobilen Gerät, also einem Gerät, das nicht für die ständige Verfügbarkeit einer Netzwerkverbindung bürgen kann. Ist das Gerät beispielsweise ein Mobiltelefon, dann gelten auch noch Hard und Softwareeinschränkungen. Oft synchronisieren solche Anwendungen ihre lokalen Inhalte mit einem Server

 ### Services

 EIn Service ist eine Komponente, die eigenständig lauffähig ist und einem Client Diesleistungen anbietet, die dieser nutzen kann. DIe KOmmunikation läuft dabei über Nachrichten ab, die vomm Client zum Service und zurück gesendet werden

 ### Webanwendungen

 Solche ANwendungen sind meistens plattformunabhängig, jedenfalls vonseiten des Clients. Sie verwenden standardisierte Technologien wie http und HTML und einne Browser für die Anzeige der Bedienoberfläche

 ### RIch CLient Application

 Anwendungen dieses Typs werden lokal ausgeführt und stellen dem Anwender meiste eine reiche Benutzeroberfläche zur Verfügung, zum Beispiel aufwendige Controls oder Grafiken. WinForm ist dafür eine typische Technologie

 ### Rich Internet Application (RIA)

 WO HTML & Co nicht ausreichen, können Technologiesn wie Silverlight das Look and Feel einer Rich-CLient-Anwendung in eine Webumgebung bringen. Das geschieht freilich
 nicht, ohne dabei einige Eigenschaften der Webanwendung aufzugeben oder einzuschränken, wie die Plattformunabhängigkeit

 ## Der ARchitekt

 In größeren UNternehmen sind Softwarearchitekten meist die erfahrensten Mitarbeiter im Unternehmen. In kleineren Unternehmen pbernehmen oft Entwickler diese Aufgabe als Querschnittsfunktion. Wie auch immer, es gibt einige Merkmale, die gute Architekten auszeichnen. Sie
- denken analytisch, können ein Problem zerteilen und auf die Komponenten auf immer neue Weise anordnen.
- kennen die eingesetzten Technologien, deren Stärken und Lmitationen,
- haben selbst schon viel programmiert und besitzen dementsprechend viel Erfahrung in der Softwareentwicklung.
- verstehen den Anwender und entwerfen die Architektur so, dass die entstehende Software für und nicht gegen ihn arbeitet.
- können sich auf verschiedenen Ebenen bewegen und betrachten ein Problem immer wieder von diesen verschiedenen Ebenen aus
- passen die Architektur an die Aufgabenstellung an und verstehen, dass Architektur kein Selbstzweck ist
- kennen die gängigen Architekturstile und können diese situationsgerecht anwenden
- beziehen alle beteiligten Personen in der Prozess mit ein: egal ob Anwender, Entwickler, Tester oder Systemintegratoren

Gerade in größen Projekten gibt es auch unter den Architekten noch eine Spezialisierun:
- Der Lead Architect trägt die Gesamtverantwortung
- Der Data Architect konzentriert sih auf die Themenfelder Datenbanken, Persistenz,Content Management System etc und alle sich daraus angrenzenden Fragestellungen wie Performance, Integration und Verfügbarkeit
- Der Infrastructure Architect erstellt eine SOftware und Hardwareinfrastruktur als GRundlage für die Anwendung selbst
- Der Integration Architect wiederum bringt die Dinge zusammen, bindet Fremdsysteme an und vereinheitlicht Schnittstellen.
- Der Application ARchitect ist der Architekt im engeren Sinne, der Struktur und Beziehungen der Anwendung entwirft

Die Rolle des Architekten ist dabei nicht immer so klar definiert, wir man sich das wünschen würde. Es gibt ARchitekten, deren Aufgaben auch in die Implementierung und in das roduktdesign reichen. ES ist aber nicht verkehrt anzunehmen, dass Architekten häufig in der Mitte des Prozesses zu finden sind. Sie halten Kontakt zum Auftraggeber, Geschäftsführer, Entwickler, zu den Administratoren und Systemingerieren und zum Produktmanager. Er benötigt selbst Informationen von diesen Personen, und diese Personen benötigen INformationnen von him. Das macht klar, dass Kommunikationsstärke eine wichtie Voraussetzung ist.

Und dann git es eben noch den Architekten in Personalunion, der diese Aufgabe nur in Teilzeit ausführt und nebenbei noch entwickelt oder das Design der Software entwirft


Und dann gibt es eben noch den Architekten in ersonalunion, der diese Aufgabe nur in Teilzeit ausführt und nebenbei noch eintwickelt oder das Design der Software entwirft.

## Anforderungen

Anforderungen stehen am Anfang einer jeden Softwarearchitektur. Obgleich einleuchtend, sind die Anforderungen in der Praxis oft das schwächste Glied in der Kette. Warum?

- Oft werden die Anforderungen erst in einer viel späteren Phase des Projekts beschrieben
- Es ist nicht klar, welche Anforderungen Auswirkungen auf die Architektur haben
- Die Anforderungen sind qualitativ und/oder quantitativ einfach nicht ausreichend

Ich habe es schon mehrfach angesprochen: ohne Spezifikation kein Projekt. Ohne Anforderungen keine Softwarearchitektur. Worauf sollte die denn sonst auch aufbauen? Anforderungen können von allen Projektbeteiligten stammen. Wichtig ist nicht so seht, wer die Anforderung stellt, sondern ob es sich wirklich um eine Anforderung handelt.
Ein Wunsch wird also erst dann zur Anforderung geadelt, wenn er Teil einer Vereinbarung ist. Das zieht die Notwendigkeit nach sich, diese schriftlich zu erfassen. Über Anforderungen ist in diesem Buch an verschiedenen Stellen zu lesen, daher soll es hier nur um Anforderungen zum Zwecke der ARchitekturfindung gehen.

## Arten von Anforderungen

Zunächst unterscheiden wir zwischen

- funktionalen Anforderungen, also Anforderungen, die mit den Funcktionen einer Software zu tun haben, wir beispielsweise Berechnugnen, Abläufe oder die verwendeten Daten. Kurzum: Es geht darum, was eine SOftware tun soll.
- nicht-funktionalen Anforderungen: darunter fallen Anforderungen, die das System als solches qualitativ näher beschreiben. Sicherheit, Performance, Benutzerfreundlichkeit, Skalierbarkeit und Wartbarkeit fallen in diese Kategorie. Hier get es also darum, wie eine Software beschffen sein soll.

IN Projekten fehlen oft die nicht-funktionalen Anforderungen, und so entstehen manchmal Achitekturen, die am Kern einer Sache vorbeigehen. Scheinbar kleine Anmerkungen kännen die Welt verändern, wie z.B:

- Die Anbindung soll auch funktionieren, wenn das Zielsystem zeitweise nicht zur Verfügung steht.
- Die Daten sollen auch auf einem Notebook "mitgenommen" werden können
- Wir wollen die SOftare später beim Kunden erweitern können, beispielsweise durch separat lizenzierte Plugins

Die Schwierigkeit liegt oftmals darin, dass Anwender (oder Produktmanager) diese Anforderungen nicht explizit definieren. Meist wissen Sie gar nicht, welche Auswirkungn solche Anforderungen auf die Softwarearchitektur haben. Es wird also umso mehr Iher Aufgabe sein, diese Anfroderungen zu hinterfragen.

Oft geschieht das nicht, aus der Befürchtung heraus, Begehrlichkeiten zu wecken. Denn wer würde auf die Frage "Wie hoch soll denn die Verfügbarkeit sein?" nicht spontan antworten: "So hoch wie möglich, am besten 100%"? Bieten SIe doch verschiedene Optionen an, aus denen der Auftraggeber wählen kann, und versehen sie jehe Option mit einme Presschild.

Denken Sie einfach immer daran: Auch wenn eine SOftware alle funktionalen Anforderungen erfüllt, kann sie dennoch in der Praxis unbrauchbar sein. Was nützt shcon eine korrekt funktionierende Auftragserfassung, die nicht bedienbar ist, oder eine Software für die Terminbörse, die nicht mit der anfallenden Last zurechtkommt?

Nicht alle dieser nicht-funktionalen Anforderungen sind für jedes Projekt gleichermaßen wichtig. SIe können sich jedoch daran orientieren, wenn Sie möchten.

- Performance: escheribt möglichst harte Kennzahlen, beispielsweise: "Das System soll in der Lage sein, in SPitzenzeiten bis zu 1.000 Bestellungen in der Minute zu verarbeiten"
- Skalierbarkeit: Im obigen Beispiel war schon von Spitzenzeiten die Rede, ein Hinweis auf Skalierbarkeit. Ein weiteres Beispiel: "Die Software soll so erweiterbar sine, dass wir damit künftig unsere Wachstumsziele abbilden können" (die dann natürlich quantitativ erfasst sein müssen)
- Sicherheit: Definiert sicherheitsrelevant ANforderungen, zum Beispiel: "Die Komponente zur Verbindung mit unseren Zulieferern soll in einem abgesicherten Bereich ausgeführt werden mit speziellen Zugriffsrechten und ohne die Möglichkeit, auf andere Bereiche der Software zuzugreifen."
- Benutzerfreundlichkeit: HIer es ist mitunter schwierig, diese Merkmal messbar zu machen. Helfen können Usability-Tests. Eine mögliche Anforderung wäre dann: "Die Software soll ein durchschnittliche Benotung von 2.2 oder besser erreichen"
- Erweiterbarkeit: Eine ALLGEMEINE aUSSAGE GENÜGT HIER NICHT, DENN VON JEDER sOFTWARE kann erwartet werden, dass sie erweiterbar ist. Es geht mehr um spezielle Anforderungen wie: "Es is geplant, bis zum Jahresende underen Kunden drei neue Module zu verkaufen, die diese dann separat lizenzieren und installieren können"
- Kompatibilität: Ist dann wichtig, wenn die Software kpmpatibel zu einem System sein muss oder gar ein Testat benötigt wird. Beispiel: "Unsere Software muss der GDPdU-entsprechen" und "Der EXport muss Open XML-kompatible Dateien erstellen" Auch Anforderungen zur Interoperabilität können in diese Kategorie fallen. Oder aber es werden gesetzliche Anforderungen gestellt, beispielsweise wenn die Medizingeräteverordnung zur Anwendung kommt
- Robustheit : Die Aspekt wird oft in prozentualer Verfügbarkeit angegeben: "Es wird eine Verfügbarkeit von 99.3% zugesichert" Oft sind an solche Aussagen Support Level Agreement gebunden und/oder es wird eine bestimmte Wiederherstellungszeit gefordert
- Supportbarkeit: SOlche Anforderungen sind meist konkreter zu fassen, denn der Begriff an sich ist nicht sehr ergiebig. Beispiel: "Unser SUpport soll, auf Wunsch des Kunden, Zugriff auf alle Fehlermeldungen erhalten". IN diese Kategorie fallen auch Anforderungen zu Logging und Tracing
- DOkumentation: Besonders dann, wenn eine SOftware im Kundenauftrag erstellt wird, kann es für Art und Umfang der DOkumentation gewisse Anfroderungen geben: Beispiel: "Der AUftragnehmer erstellt für die fünf wichtigsten Prozesse Tutorials, mit einem Umfang zwischen 5-10 Seiten pro Tutorial"

Diese Aufstellung ist nicht vollständig,  vielleicht gibt es ja gerade für IHr Projekt zusätzliche nicht-funtionale Anforderungen? Manchmal zählt man auch die Ressourcen zu den nicht-funktionalen Anforderungen. Ich sehe das nicht so, denn letztlich steht das gesamte Projekt unter den Einschrönkungen der verfügbaren Zeit und der vereinbarten Kosten. Wichtig ist jedoch, dass der gesamte Prozess der Gewinnung von Anforderungen dem Rechnung trägt. Oder anders ausgefrückt: Wünsche sind unbegrenzt, Anforderungen sind es nicht.

Aber auch wenn Sie kleine Brötchen backen, alleine das Bewusstsein für die nicht-funktionalen Aspekte von Softwaresystemen ist der vielleicht schon wichtigste Schritt. Überlassen SIe das ERgebnis nicht dem Zufall

## Anatomie einer ANforderung

Die meisten ANforderungen, die mir im Laufe der Zeit begegnet sind, waren wenig bis gar nicht strukturiert. Für einen Softwarearchitekten (und auch für die meisten Entwickler) gibt es nichts Schlimmeres, als sich durch Dutzende Seiten kafkaesken Prosatext zu quälen, der noch dazu unpräzise, widersprüchlich und lückenhaft ist. Wenn möglich, geben Sie doch einfach den AUfbau vor. Eine Anforderung sollte enthalten:
- die Bezeichnung und eine eindeutie Referenznummer
- das Ziel, bzw den Zweck dieser ANforderung (eventuell noch ergänzt um den quantitativen Nutzen, der aus der Erfüllung der Anforderung entsteht)
- die beteiligten Systeme und MEnschen, die daran mitwirken
- die Eingabedaten
- die SChritte der Verarbeitung
- die Ausgabefaten
- die Priorität
- die Relevanz für die SOftwarearchitektur (Diesen ABschnitt ergänzen SIe)

## Beispeil:
No. FR6934:
- Die Artikelstammdaten sollen in XML exportiert werden können
Ziel, Zweck:
- Artikel können so zwichen Standorten und Mandanten ausgetauscht werden, und unsere Kunden können die Daten selbst weiterverarbeiten
Beteiligte
- Der Export wird manuell gestartet.
Eingabedaten
- Alle Artikeldaten von allen Produkten, die nicht bereits stillgelegt wurden.
Schritte
- Auswahl der Programmfunktion
- AUswahl eines Verzeichnisses und Dateinamen
- Export
- Vermerken des Vorgangs im Systemprotokoll
Ausgabedaten
- XML-Datei mit allen Artikeln und deren Daten
Priorität
- 2 (4, wenn die Multi-Mandantenfähigkeit umgesetzt wird)
Architekturrelevanz
Da die Daten auch für Kunden interressant sein könnten, sollte das Exportformat varianbel sein. Auswirkung: Funktion als Plugin implementieren, im eingenen Layer

Wenn SIe jetzt noch ein einheitliches Werkzeug zur Erfassung und Dokumentation solcher Anforderungen einsetzen, dann haben SIe sich die Sache ein wesentliches Stück einfacher gemacht.

Fassen wir noch einige qualitative Merkmale zusammen, die eine gute Anforderung ausmachen:
- Sie ist knapp, präzise, möglichst vollständig und konkret
- SIe ist fachlich formuliert, denn diejenigen, die Anforderungen stellen, kommen nur selten mit technischen Begriffen klar
- Sie stammt von den richtigen Mitarbeitern, also den Mitareitern, die ein Interesse an der jeweiligen Anforderung haben
- Sie lässt sich abschätzen bzw messen und vermedet allgemeine Formulierungen.
- Sie berücksichtigt, dass man nicht alles haben kann. Eine Möglichkeit, dies zu zeigen, sind Prioritaäten.
- Idealerweise steht sie nicht alleine, sondern befindet sich in einem Kontext, beispielsweise ist sie Teil eines Use Cases

## Das richtige Maß

Wenn hier von Anforderungen die Rede ist, dann immer in dem Maß, wie sie für die SOftwarearchitektur notwendig sind. DIe beiden wichtigsten Aufgaben des SOftwarearchitekten sind also
1. sicherstellen, dass die Anforderungen (besonders auch die nicht-funktionalen) so vollständig wie möglich vorliegen und
2. diejenigen Anfoderungen auswählen, die einen maßgeblichen Einfluss auf die ARchitektur der Software haben

Die Relevanz einer Anforderung für die Architektur ist nicht immer leicht zu erkennen. Vielleicht helfen Ihnen dabei einige Kriterien, die solche Anforderungen erfüllen können:
- Sie beschreibt eine Verbindung nach außen, beispielsweise durch eine Scnittstelle
- Sie veranschaulicht einen erfolgskritischen Bereich der SOftware
-  Sie ist schwer zu erfüllen
- SIe birgt ein gewisses Risiko
- Sie beeinflusst maßgeblch die Datenhaltung.

Vermutlich werden die Anforderungen den Rahmen sprengen. Das ist nicht grundsätzlich schlecht, denn es zeigt, dass die Beteiligten auch Anforderungen haben. Und es eröffnet die Möglichkeit, auszuwählen, also die Aspekte umzusetzzen, die den besten Kosten/Nutzenfaktor versprechen. Zu guter Letzt nimmt es einen Teil des Produkt-Lebenszyklus vorweg, denn nicht umgesetzte Anforderungen können ja immer noch in einer Folgeversion umgesetzt werden

Der gesamte Prozess zur Gewinnung solcher Anforderungen wird gerdne als Requirements Management bezeichnet und kann inder Praxis belibig komplex werden. Das richtige Maß bedeutet also auch, rechtzeitig aufzuhören. Wenn Sie die Anforderungen definieren, hinterfragen, auf IHre Bedeutsamkeit hinsichtlich der Architektur untersuchen, dokumentieren und idealerweise noch priorisieren, dann sind SIe vermutlich auf der sicheren Seite und können sich dem nächsten Shritt zuwenden, der Identifizierung der beteiligten Komponenten

## Komponenten

Der Begriff Komponente ist ganz allgemnein zu verstehen, nämlich als eine nahezu beliebige Einheit eines Softwaresystems. Damit ist es eine der wichtigsten Aufgaben, solche Komponenten erst einmal zu identifizieren.

### Komponenten identifizieren

Dies kann beispeilsweise geschehen aufgrund
- funktionaler Zusammengehörigkeit - eine Komponente umfasst also Funktionen, die ähnliche Aufgabne erfüllen
Beispiel: Die Komponente Login-Verwaltung beinhaltet alle Funktionen zum ANMELDEN NEUER bENUTZER ZUM lOGIN BESTEHENDER aNWENDER UND FÜR die Verwaltung, beispielsweise dem Zusenden vergessener Passwörte
- Fachlicher Zusammengehörigkeit - ein Komponente bedient also denselben fachlichen Kontext
Beispiel: Die Komponente Werbuing beinhaltet alle werblichen Aspekte, beispielsweise den Newsletter.Versand oder die Anreicherung der Anwnderdaten mit Daten, die aus dem Anwenderverhalten gewonnen werden
- ähnlicher Daten - Komponenten nutzen also dieselben Tabellen und andere Datenbankobjekte
Beispiel: DIe KOmpnente Kunde greift auf Objekte des gleichlautenden Datenbankschemas zu, beispielsweise die Kundenstammtabelle oder die Adresshistorie.

Neben diesen Ordnungskriterien gibt es noch viele weitere. UB duesen Kapitel verwende ich den Begriff Komponente für jegliche Detailtiefe, was die Sache einfacher macht. In der Literatur sind noch die Begriffe System und Subsystem anzutreffen, die dann häufiger auf den oberen Ebenen der Architektur angewendet werden, aber dasselbe meinen

## Arten von Komponenten

Grundlagen für die Komponenten sind:
- funktionale und nicht-funktionale Anforderungen
- ein umbegendes System, also die IT-Landschaft, in der die neue Applikation eingebunden werden soll
- Geschäftsobjekte und Funktiosbereiche der Software
Daraus ergeben sich verschiedenen Arten von KOmponenten:
- fachliche Fremdsysteme, z.B eine bereits vorhandene Buchhaltungs-Software
- technishce Fremdsysteme, z.B der eingesetzte SQL server
- Schnittstellen und andere Formen der Verbindung, z.B die Anbindung an eine VRM-Software, an die Kundenstammdaten übergeben werden
- explizite Grenzen, z.B Sicherheitsgrenzen einer DMZ, in der Komponenten ausgeführt werden
- Komponenten, die Funktionen ausführen, z.B eine Komponente für die Verwaltung des Lagers
- Daten, z.B ein Cache, in dem Stammdaten zwischengespeichert werden
- technische Komponenten, z.B die Leistungsüberwachung von Windows, an die andere Komponenten ihre Laufzeitdaten übermitteln
- Infrastruktur-Komponenten, z.B eine Enterprise Service Bus

## Der Prozess

Die meisten Architekten folgen einem Top-Down-Ansatz. Zuerst identifizieren sie also die obersten Komponenten und verfeinern dann jede Komponente, bis sie den gewünschten Grad an Detailreichtum erreicht haben.

Das klingtt gut, ist in der Praxis aber häufig nicht zu realisieren. Denn eine solche Vorgehensweise verlangt, dass die Komponenten der Ebene nach benannt werden können. Viel häufiger ist daher ein iterativer Ansazt anzutreffen, in der (zunächst im Top-DOwn-Ansatz) komkponenten identifiziert und in Beziehung zueinander gebracht werden. Im laufe des Prozesses werden immer mehr Anforderungen in die Architektur eingebracht, und die vorhandenen Komponenten werdn einem Refactoring unterzogen.: Komponenten werden entfernt, zusammengefasst, aufgeteilt, in der Hierarchie nach oben oder nach unten versetzt oder neu andeordnet.

Um KOmponenten zu identifizieren, können SIe die folgenden Fragen stellen:

- Ist die Komponente wirklich für eine eigenständige Funktion zuständig, und ist die lose an andere Komponenten gekoppelt
- Ist sie auch wirklich nur für einen Funtionsbereich zuständig?
- Knn sie wiederverwendet werden, stellt sie also eigenständige Dienstleistungen zur Verfügung?
- Gibt es Einschränkungen, die die Bildung einer eigenen Komponente erforderlich macht, zum Beispiel, weil die Komponente eine Sicherheitsgrenze darstellt?
- Ist die KOmponente Teil einer größeren Komponente, oder ist sie unabhängig?
- Ergibt sich die KOmponente aus dem technischen UMfeld oder aus den fachlichen ANforderungen?

Ebenfalls häufig trifft man auf das umgekehrte MOdell, also einen Bottom-UP-Ansatz: DIe Komponenten werden erst einmal aus der Anforderungen destilliert und gesammelt. Erst im zweiten Schritt wird dann eine Struktur daraus gebildet und jede Komponente enthält ihren Platz. Einen pauschalen Ratschlag für IHre SItuation kann ich Ihnen nicht geben, aber einige Empfehlungen:

- Vielleicht gibt es bereits Komponenten anderer Systeme, dann bilden diese einen ersten Ordnungsrahmen.
- Gleisches gilt auch für technische KOmponenten, beispielsweise einen bereits vorhandenen Applikationsserver
- Wenig Mühe bereitet meist die Bildung von KOmponenten mit einigem Umfang, zum Beispiel "Werbung", "Auslieferung" oder "Kundenverwaltung". Diese Komponenten können Sie dann zuerst niederschreiben und im Folgenden aufteilen, anordnen und verfeinern.
- Es lohnt sich eigentlich immer, Schnittstellen als eigenen Komponenten darzustellen.
-  Nicht selten sind wichtige Komponenten aus den Anforderungen schwer oder gar nicht herauszulesen. Der Katalog der nicht-funktionalen Anforderungen kann IHnen dann weiterhelfen, wenn Sie beispielsweise fragen: "Wird eine Benutzer- und Recteverwaltung benötigt?" Daraus ergeben sich dann meist weitere Komponenten, im genannten Beispiel könnte dies die Anbindung an ein vorhandenes Active Directory sein.

## Beziehungen

Die Frage, wie Komponenten zusammenwirken und in welcher Beziehung sie zueinander stehen, bestimmt oft maßgeblich die Auswahl und Abgrenzung der Komponenten selbst. Dabei können Komponenten auf verschiedene Weise voneinander abhängig sein:
- Hierarchisch: Komponenten haben übergeordnete, allgemeinere Komponenten.
- Enge Kopplung: Einzelne KOmponenten sind eng aneinander gebungden, lassen sich also nicht ohne diese anderen Komponenten verwenden.
- Lose Kopplung: Die Komponenten sind nur lose gekopplet, ihre IMplementierung lässt sich also leichter ändern, ohne das Gesamtsystem zu gefährden, und sie lassen sich für andere Aufgaben einfacher wiederverwenden.
- Dependency Injection: Die Objektnetze lassen sich zur Laufzeit knüpfen, vorwiegend durch flexible Konfiguration statt fester Programmierung

Diese ABhängigkeiten sind nicht nur technisch zu sehen, sondern auch fachlich (mit Ausnahme der Dependency Injection, die ein technisches Entwurfsmuster beschreibt). Die technische Abhängigkeit sollte der fachlichen Abhängigkeit entsprechen.
Neben der Abhängigkeit gibt es noch weitere, konkretere Möglichkeiten, Beziehungen zu bestimmen. Dabei geht es um die Frage, warum zwei Komponenten überhaupt in Beziehung zueinander stehen. Das kann sein, weil:
- Eine Komponente Funktionen einer anderen KOmponente verwendet. Beispiel: Der Service zur Verarbeitung von Bestellungen verwendet den LagerService, indem er dort Abbuchenen vornimmt
- Eine Komponente Daten an eine andere Komponente sendet. Beispiel: Ein E-Mail-Marketingswerkzeug sendet der Komponente zur Verwaltung der Werbeaktionenen INfo darüber, welche Kunden welche Werbung erhalten haben.
- eine Komponente beim Eintreten eines Ereignisses informiert werden möchte.Beispiel: Die Komponente zur Berechnung des Data Warehouse möchte informiert werden, sobald alle Buchungen des Tages verarbeitet werden, damit sie die Berechnugn der Cubes daraufhin starten kann.

Beziehungen können unidirektional oder bidirektional sein.

## Prozesse

Der Begriff Prozess hat viele Bedeutungen. Gemeint ist hier der Geschäftsprozess als Grundlage für die meisten heutigen Geschäftsanwendungen

### Was ist ein Prozess?

Prozesse bringen die Komponenten in einen zeitlichen Kontext. Aus der Ausführung einzelner Aktivitäten einsteht ein Prozess, wenn dass ERgebnis einer AKtivität wiederum mit einer anderen Aktivität verbunden ist. Prozesse sind charakterisiert durch:
- einen Anfang,
- ein Ende
- Aktivitäten, den Bausteinen von Prozessen
- Verbindung zwischen den Aktivitäten, die diese entweder schrittweise oder fallbezogen miteinander verknüpfen, und durch
- ein Ziel, dem der Prozess dient.