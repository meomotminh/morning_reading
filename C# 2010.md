### Gute SOftware, Schlechte Software

VOr gut zehn Jahren hatte ich den ersten Kontakt mit einem damals neuartigen Online-CMS (Content Management System). Es war kurz vorher bei einem Unternehmen eingeführt worden, in dem ich als Leiter der Online-Entwicklung eingestellt wurde. Es stammte von einem renommierten Unternehmen, hatte einen klangvollen Namen, und die Verkäufer konnten mit einer langen Referenzliste worden. Meine Aufgabe sollte es sein, auf Basis dieses Systems zahlreiche neue ONline-Auftritte zu entwickeln, gemeinsam mit eigenne und freiberuflichen Mitarbeitern.

Für den Einkäufer dieses CMS war das eine sichere Sache, sollte man meinnen. IM praktischen Einsatz wurden sehr bald die Mängel deutlich, und die waren gravierend: Das System lahmte selbst auf den schnellsten Servern, es war instabil, ganz und gar kontra-intuitiv zu bedienen, schwer zu administrieren und mit allerlei eigenen, proprietären Lösungen für ganz alltägliche Probleme ausgesstattet.

Hotline, Entwicklung und Geschäftsleitung des Softwareherstellers hatten das Problem längst ausgemacht: Der Kunde sei das Problem, das System liefe schließlich in großen Installationen zuverlässig und, soweit man wisse, problemlos. Das wollte ich nicht recht glauben, und so begann ich, mit diesen Referenzkunden zu telefonieren und sie zu besuchen. Und wie es zu erwarten war, glichen sich die Probleme. Viele UNternehmen berichteten über genau die Schwierigkeiten, die auch wir hatten.

Und so war das Ende unausweichlich: Nach einigen erfolglosen Resleases tauschten wir das System gegen ein CMS aus, das aufff offenen Standards wir PHP und MySQL aufbaute, kaum ein Zwanzigstel so teuer und wenigstens zehnmal so schnell war. Dieses System läuft auch heute noch.

Seitdem habe ich mich in zahlreichen Projekten immer wieder gefragt: Was macht gute Software aus, und was unterscheidet sie von schlechter Software? Warum lässt sich die eine Software elegant und preiswer erweitern, während sich andere Programme vehement gegen jede Form der Anpassung sträuben? Warum gibt es Lösungen, mit denen sich flüssig arbeiten lässt, während bei anderen jeder Klick zum Geduldsspiel wird, und warum gibt es so viele gute Benutzeroberflächen, aber warum auch so viele schlechte? Wieso kann der Aufwand fürdas Customizing einen Brchteil des Kaufpreises ausmachen, aber auch leicht ein Mehrfaches, und warum müssen manche Softwareprodukte bei jedem neuen Release in großen Teilen neu geschrieben werden, während andere über viele Jahre hinweg scheinbar mühelos erweitert werden können?

#### Wege zur Lösung

Ich behaupte nicht, die Antwaort auf all diese Fragen zu kennen. Aber ich habe über die Jahre zahlreiche Muster entdeckt, Fallstricke, wenn Sie es so nennen möchten, aus den eigenen Projelkten heraus, aber vor allem in der Zusammenarbeit mit meinen Mitarbeitern, eexternen Programmierern, Auszubildenden und Consultants.  Aus meinen und ihren Erfahrungen ist dieses Buch entstanden. Es verfolgt 3 Ziele:

**Wissen erweitern**
Geradeich kleineren UNternehmne müssen Entwickler oft wahre Allrounder sein. Denn neben fundierten Fertigkeiten in verschiedenen Programmiersprachen benötigen Sie noch viele weitere Kenntnisse, beispielsweise in Fragen der Softwarearchitektur, im Softwaredesign, in ihrer Entwicklungsumgebung, in den verschiedensten eingesetzten Technologiesn, in Softwaretests, Projektmanagement und Datenbankentwurf.

NIch jeder Entwickler hat die Zeit, Lust oder Gelegenheit, sich durch viele Regalmeter Fachliteratur zu arbeiten. Dieses BUch macht den durchaus gewagten Versuch, die wichtigsten Bereiche der Softwareentwicklung in einem einzigen Werk zu behandeln, von der richtigen Architektur über die UMsetzung bis hin zur Softwarepflege nach deren Einführung. Damit ist es ein Buch für "Aufsteiger", also Entwichler, die dazulernen möchten und die über Bekanntes aus einem anderen BLickwinkel neu nachdenken wollen

**Problem vermeiden helfen**

In diese BUch finden SIe immer wieder Kästen mit dem Titel "Aus der Praxis". In diesen Kästen finden SIe das eine oder andere Problem, das ich inder Vergangenheit selbst erlebt habe, und meist einen Lösungsansatz dazu. Vielleicht erkennen SIe bisweilen Ihr eigenes Projekt darin wieder, dann betrachte ich SIe als Leidensgenossen, wenn Sie erlauben. Ansonsten täten Sie mir einen großen Gefallen, wenn Sie diese Problem vermeiden würden

Ich habe beim Schreiben bisweilen selbst gestaunt, wie viele Fehler mir während der Jahre unterlaufen sind. Viele wären leicht zu vermeiden gewesen, bei anderen lagen ihre Ursachen etwas tiefer

**Best Practices vermitteln**

Der Begriff *Best Practices* stammt eigentlich aus der Betribeswirtschaft und bezeichnet bewährte Verfahren, die sich für gleiche oder ähnliche Aufgabenstellungen eignen. *Entwurfsmuster* oder *Design Patterns* sind fertig Lösungen oder Lösungsschablonen für häufig widerkehrende Probleme in der Softwareentwichlung. SIe könne damit ebenfalls inm weiteren Sinne den Best Pracktices zugerechnet werden.

Myriaden von Problemen entstehen durch die falsche oder unzureichenede IMplementierung häufig wiederkehrender Aufgabenstellungen. Niht selten hat jeder Entwickler seine eigene Lösung entwickelt. Dabei sind viele dieser Aufgabenstellungen im Detail komplex, die Lösungen aber meist zu einfach,  wie das folgende Beispeil zeigt

´´´
    Um mit Services zu kommunizieren, die mit WCF (Windows COmmunication Foundation) entwickelt wurden, benötigt man einen Proxym, ein Objekt also, das die Kommunikation mit dem Service kapselt. In vielen Lehrbüchern findet man dazu Beispiele wie:
        MyServiceClient client = new MyServiceClient();
        client.Open();
        try
        {
            client.DoSomething();
        }
        catch (Exception ex)
        {
            MessageBox();
        }
        client.Close();
´´´

Dieses Beispeil funktioniert und ist daher in vielen Programmen verwirklicht. ES ist aber wenig praxistauglich, den Verbindungsabbrüche, Timeouts, SIcherheitsprobleme und einige andere aufgetretende Ausnahen verlangen nach jewielts speziellen Behandlungen. Das ist unverzichtbar für ein robustes und fehlertolerantes Programm.

IM Grunde genommen müsste sich nun jeder Entwickler in die Tiefen der WCF-Kommunikation begebenm, um selbst eine adäquate Lösung zu entwickeln, oder er greift auf das Client-Pattern in Kapitel 6, "Windows Communication FOundation", zurück.


# Das Fallbeispiel

An der einen oder anderen Stelle vewende ich ein Fallbeispeiel, gewissermaßen als Kontrastprogramm zu den allerorts beliebten "Hallo Welt!" Beispeielen. Herzlich willkommen also in der Welt der Kalimba Sunfood mb, dem Premium IMporteur für sonnenverwöhnte Früchte aus aller Welt mit Sitz in Hamburg.

Unsere Firma importiert Waren aus aller Welt und benötigt hierfür eine Enterprise Resource Planning Software zur Stererung aller betrieblichen Funktionen, also:
- Warenwirtschaft
- Kundenerwaltung
- Finanz und Rechnungswesen
- Verkauf und Marketing
- Controlling ung
- Personalwirtschaft

Es werden etwa 800 Mitarbeiter beschäftigt, die Hälfte am Stammsitz in Hamburg, die andere Hälfte verteilt auf mehrere Standorte weltweit. Kalimba Sunfood kauft die Früchte vor Ort ein, beispeielsweise Orangen aus Brasilien oder Mangos aus Indien, exportiert sie nach Deutschland und vertreibt sie dort an Großhändler und die Getränkeindustrie. Darüber hinaus betreibt die Gesellschaft einnen Onlineshop für Cocktail-Fruchtsäft, in dem Privatkunden direkt bestellen können.

Die beiden Niederlassungen in den USA und Indien sind bereitbandig an die Zentralle angeschlossen, ihre Mitarbeiter nutzen Rich-CLient-Anwendungen. Die Büros der Einkäufer sind schmalbandig ageschlossen, daher greifen die dortigen Mitarbeiter über das Internet auf Webanwendungen zu. Natürlich setzt die hausinterne Entwicklungsabteilung auf .NET als Kerntechnologie und dazu noch auf
- Winforms für die Rich-Client-Anwendungen
- ASP.NET für die Webanwendungen
- WCF für die serviceorientierte Mittelschicht
- WF für die Verarbeitung der Bestellungs-Workflows
- VS 2010 Premium als Entwicklungsumgebung und auf
- SQL server 2008 als Datenbanksystem
Das zu entwickelnde ERP-System nennt unsere Firma das Kalimba.ERP

# Architekturentwurf

EIn Kapitel üüber Softwarearchitektur in einem Praxis buch, passt das zusammen? Ja, wenn wir Softwarearchitektur als das verstehen, was sie ist - als notwendigee Grundlage für den Bau erfolgreicher Software

Architektur ist kein Selstzweck, und Architekturdiagramme sind nur selten etwas, für das derAuftraggeber bezahlen möchte. Der allseits bemühte Vergleich mit den Architekten im Bauwesen stellt klar: ohne Architekt kein Gebäude, ohne Softwarearchitekt kein Softwareprodukt. Ich meide solche Vergleiche jedoch, denn Bau und Softwarearchitekten haben nur wenig gemeinsam. Während es im Baugewerbe unzählige Regeln und Normen gibt, treffen wir in der SOftwareentwicklung, wenn überhaupt, auf Best Practices. Und wo sich die Bauvorhaben großteils ähneln, ist jede SOftware eine Einzelanfertigung. Mehr noch: Imgegensatz zum Bauarchitekten gibt es für Softwarearchitekten keine allgemein anerkannte und weitverbreitete Ausbildung, ja noch nicht einmal über deren Aufgaben besteht Einigkeit



Morgen zusammen, ich arbeite gerade an meiner Bachelorsarbeit. Ich wende mich an mein Professor und er slug mir vor, mit dem Entwurf und Implementierung zu beginnen. Jetzt versuche ich mein CAN protol zu schreiben und auf Arduino Portenta H7
zu implementieren.

Softwarearchitekten stehen nicht im Ruf Pragmatiker zu sein, und meist leisten sich nur große Projekte einen eigenen Architekten. Dabei kann auf eine gute Softwarearchitektur als Grundlage für moderne Software nicht verzichtet werden. Architektur findet immer statt. DIe frage ist nur: Ist sie das Ergebnis planvollen Handelns, vor der Implemnetierung, oder entsteht sie aus der Erfahrung einzelner Entwickler heraus, während der Entwicklung

Ich möchte IHnen in diesem Kapitel die Softwarearchitektur nähebringen, als eigenen Teilschritt innerhalb des Entwicklungsprozesses. Sie werden sehen: Softwararchitektur ist viel prakticher, als Sie vielleicht denken, und viele Fragestellungen wirken direkt auf die spätere Implementierung.

Dieses Kapitel handelt zwar von der Softwarearchitektur, dennoch ist die Grnzlinie zum Softwaredesign nicht scharf zu ziehen. Diese Kapitel verschmilzt daher sozusagen mit dem nächsten Kapitel zu einer EInheit. Mein wichtigstes Ziel ist, das Feld zu bestellen, auf dam Archtektur stattfindet und die richtigen Fragen zu formulieren, die dann zu den hoffentlich richtigen Antworten für Ihr Projekt führen.

# Einführung

In diesem Abschnitt werden wir Softwarearchitektur dingfest machen. Sie werden sehen, warum es sich lohnt, Zeit darauf zu verwenden, und Sie werden die Grundzüge guter Architektur kennenlernen

## Das Problem

Die Kalimba Sunfood Gmbd möchte ihr Angebot um eine Online-Bestellmöglichkeit für Einzelhändler erweitern. Alice, die Programmmanagerin, und Bob, der Entwicklungsleiter, treffen sich zu einer Besprechung:

Alice: Hi Bob, es  geht um das Konzept, das ich dir letzte Woche gemailt habe. Wie du weißt, findet in 2 Monaten die Food-Pro Messe in Barcelona statt, und wir möchten unser neues Vertriebskonzept für Einzelhändler vorstellen. Dafür benötigen wir einen Onlnie-Shop, den wir dort präsentieren können.

Bob: OK, dein Grobkonzept lässt aber viele Fragen offen. Wir identifizieren wir beispeilsweise unsere Kunden im Web, wie kommen die individuellen Verkaufskonditionen auf die Internetsetite, und wie läuft dann die Bestellabwicklung ab.

ALice: Aber das sind doch alles technische Details, dafür seid ihr ja in der Entwicklung zuständig. Für mich sind die fachlichen Aspekte wichtig, die ich im Konzept ja ausführlich beschrieben habe.

Bob: NIchts für ungit, aber fpr eine Umsetzung sind sieben Seiten nicht ausreichend. Es geht auch darum, wie wir diese neue Software in die bestehende Softwarelandschaft einbinden könne. Der neue Vetriebsweg is ja nicht eigenständig, viele Prozesse laufen auch außerhalb der Website, beispielsweise im Kalimba.ERP, und die Daten sollen doch zentral gespeichert werden, oder?

Alice: Von Datenbanken verstehe ich nichts, aber wenn wir die Software nicht zur Food-Pro vorstellen könne, dann verlieren wir Marktanteile-unsere Wettbewerber bieten solche Lösungen schon seit Jahren. Hier geht es um time-to-market, die Lösung muss unbedingt fertig werden, in Schönheit sterben können wir später auch noch.

Bob: Ween wir dir jetzt eine vermeintlich einfache Lösung bauen, dann wird uns die Pflege ein Vielfaches kosten, die Werbeabteilung hat keinen einheitlichen Blick mehr auf den Kunden, und viele Prozesse werden manuell ablaufen müssen.

ALice: Wenn wir keine einfache Lösung zur Messe haben, dann werden die Kosten viel höher sein. Kannst du nicht einfach einen Prototyp bauen? Wir wissen ja noch gar nicht, wir das neue Vertriebsmodell ankommt, und deswegen steht auch kaum Budget bereit. Wenn es funktioniert, dann bringen wir einfach eine Version 2 mit all den tollen Features, die ihr Programmierer euch wünscht

Es kommt wir es kommen muss: Zur Messe steht eine "Version 1" zur Verfügung, ein Provisorium, für dessen grundlegende Überarbeitung dann später Zeit und Geld fehlen. ABer was ist daran auszusetzen?

## ut Softwarearchitektur, schlechte SOftwarearchitecktur

Softwarearchitektur ist schwer zu greifen, weil ihre Aufgaben so vielschichtig sind. Dennoch gelingt es uns leicht, die Auswirkungen schlechter Architekturentscheidungen zu erkennen:

Merkmal                                 Auswirkung
- Komlexität:                        Lösungen erscheinen uns unbeherrschbar komplex, das Gesamtbild ist nicht erkennbar, die ersten Schritte zur Umsetzung sind unklar
- Kosten/Termintreue: Die Projektkosten laufen aus dem Ruder, der Zeitplan gerät ins Wankenaus. Die Lösung muss immer wieder umgebaut werden, da neu entwickelte Teile nicht zu den bereits vorhandenne Teilen passen
- Redundanz: Dieselben Aufgabenstellungen werden mehrfach gelöst, in unterschiedlichem Kontext und unterschiedlichen Modulen. Dennoch lassen sich diese Module aber nicht mehr in anderen Anwendungen wiederverwenden
- Performance: Das System ist zu langsam, die einzelnen Komponenten arbeiten nur unzureichend zusammen.
- Integration: Die einzelnen Module passen nicht so recht zusammen, sie enthalten oft Hilfskonstruktionen, damit sie überhaupt kompatibel sind und verlieren damit an Unabhängigkeit. Es gibt viele Schnittstellen, die alle recht unterschiedlich implementtiert sind.
- Wartbarkeit: Neue Anforderungen lassen sich nur umsetzen, wenn immer wieder große Teile der Software umgebaut werden. Nur wenige Mitarbeiter beherrschen daher die Implementierung neuer Funktionne
- Konfiguration: Anforderungen müssen programmiert werden, auch wenn eine Konfigurationsänderung eigentlich genügt hätte
- Dokumentation: Die Dokumentation ist schwer zu lesen, beschreibt viele Ausnahmen und lässt den inneren Zusammenhalt vermissen
- Pflegephase: Die Umsetzung neuer Anforderungen dauert lange, kostet viel und birgt ein hohes Risiko für neu auftretende Fehler
- Qualität: Anwender, Entwickler  und Tester bemängeln die Qualität der Software. Sie benimmt sich zunehmend unberechenbar, und der AUfwand für die Fehlersuche und Fehlerbehebung nimmt überproportional zu

 Natürlich liegen die Gründe für die obengenannten Probleme nicht ausschließlich in einer mangelhaften Architektur. Manchmal ist auch einfach nur die UMsetzung fehlerhaft, oder die Tests wurden nicht gewissenhaft genugt durchgeführt; dennoch sind die Symptome typisch, und einige davon finden sich sicher in einer Software wieder, wenn der Architektur nicht der nötige Stellenwert zukommt.

 ## Aufgaben

 Literatur und Wissenschaft bieten uns viele Definitionen des Begriffs Software architektur. Vielversprechender scheint mir allerdings die Frage zu sein: Womit beschäftigt sich SOftwarearchitektur? Wir könnten nun einfach sagen: Sie beschäftigt sich damit, die oben dargestellten Probleme zu vermeiden! Das wäre nicht verkehrt, aber ein wenig genauer:
 In der Softwwarearchitektur geht es darum.
 - Die Komponenten eines Softwaresystems zu identifizieren
 - diese in Beziehung zueinander zu bringen dund die Art dieser Beziehungen zu erkennen und zu beschreibung
 - die Konfiguration und deren Eigenschaften zu bestimmen
 - die INfrastruktur um diese Komponenten herum richtig auszuwählen und richtig anzuwenden, und
 - die einzelnen SOftwaresysteme so miteinander zu verbinden, dass ein funktionierendes Ganzes entsteht

 Oder anders ausgedrückt: Architektur macht Komplexität erst beherrschbar. Wichtigtes Hilfsmittel ist also die Analyse. Eine Aufgabe wird zerlegt und die KOmponenten den Zielen entsprechend angeordnet

 ## Anwendungstypen

 IN der praktischen Architektur ist es nicht ausreichend, Komponenten, Beziehungen und Schichten ausfindig zu machen bzw zu entwerfen, sondern es müssen Grundlagenentscheidungen getroffen werden. Hier verschwimmt die Grenze zum SOftwaredesign. Betrachten wir eine Anwendung, wie Lotus NOtes. Mit dieser können Daten auch lokal, ohne Zugriff auf einen Server, bearbeitet werden. Ein solche Software benötigt ein anderes Design, aber auch eine andere Architektur als eine reine Client/Server Lösung, in der ein Server immer zur Verfügung steht
 Es ist daher sinnvoll, einige Anwendungstypen zu definieren, wobei auch hier die Trennlinie nicht messerscharf zu ziehnen ist

 ### Mobile Anwendung

 Eine Anwendung dieser Kategorie läuft auf einem mobilen Gerät, also einem Gerät, das nicht für die ständige Verfügbarkeit einer Netzwerkverbindung bürgen kann. Ist das Gerät beispielsweise ein Mobiltelefon, dann gelten auch noch Hard und Softwareeinschränkungen. Oft synchronisieren solche Anwendungen ihre lokalen Inhalte mit einem Server

 ### Services

 EIn Service ist eine Komponente, die eigenständig lauffähig ist und einem Client Diesleistungen anbietet, die dieser nutzen kann. DIe KOmmunikation läuft dabei über Nachrichten ab, die vomm Client zum Service und zurück gesendet werden

 ### Webanwendungen

 Solche ANwendungen sind meistens plattformunabhängig, jedenfalls vonseiten des Clients. Sie verwenden standardisierte Technologien wie http und HTML und einne Browser für die Anzeige der Bedienoberfläche

 ### RIch CLient Application

 Anwendungen dieses Typs werden lokal ausgeführt und stellen dem Anwender meiste eine reiche Benutzeroberfläche zur Verfügung, zum Beispiel aufwendige Controls oder Grafiken. WinForm ist dafür eine typische Technologie

 ### Rich Internet Application (RIA)

 WO HTML & Co nicht ausreichen, können Technologiesn wie Silverlight das Look and Feel einer Rich-CLient-Anwendung in eine Webumgebung bringen. Das geschieht freilich
 nicht, ohne dabei einige Eigenschaften der Webanwendung aufzugeben oder einzuschränken, wie die Plattformunabhängigkeit

 ## Der ARchitekt

 In größeren UNternehmen sind Softwarearchitekten meist die erfahrensten Mitarbeiter im Unternehmen. In kleineren Unternehmen pbernehmen oft Entwickler diese Aufgabe als Querschnittsfunktion. Wie auch immer, es gibt einige Merkmale, die gute Architekten auszeichnen. Sie
- denken analytisch, können ein Problem zerteilen und auf die Komponenten auf immer neue Weise anordnen.
- kennen die eingesetzten Technologien, deren Stärken und Lmitationen,
- haben selbst schon viel programmiert und besitzen dementsprechend viel Erfahrung in der Softwareentwicklung.
- verstehen den Anwender und entwerfen die Architektur so, dass die entstehende Software für und nicht gegen ihn arbeitet.
- können sich auf verschiedenen Ebenen bewegen und betrachten ein Problem immer wieder von diesen verschiedenen Ebenen aus
- passen die Architektur an die Aufgabenstellung an und verstehen, dass Architektur kein Selbstzweck ist
- kennen die gängigen Architekturstile und können diese situationsgerecht anwenden
- beziehen alle beteiligten Personen in der Prozess mit ein: egal ob Anwender, Entwickler, Tester oder Systemintegratoren

Gerade in größen Projekten gibt es auch unter den Architekten noch eine Spezialisierun:
- Der Lead Architect trägt die Gesamtverantwortung
- Der Data Architect konzentriert sih auf die Themenfelder Datenbanken, Persistenz,Content Management System etc und alle sich daraus angrenzenden Fragestellungen wie Performance, Integration und Verfügbarkeit
- Der Infrastructure Architect erstellt eine SOftware und Hardwareinfrastruktur als GRundlage für die Anwendung selbst
- Der Integration Architect wiederum bringt die Dinge zusammen, bindet Fremdsysteme an und vereinheitlicht Schnittstellen.
- Der Application ARchitect ist der Architekt im engeren Sinne, der Struktur und Beziehungen der Anwendung entwirft

Die Rolle des Architekten ist dabei nicht immer so klar definiert, wir man sich das wünschen würde. Es gibt ARchitekten, deren Aufgaben auch in die Implementierung und in das roduktdesign reichen. ES ist aber nicht verkehrt anzunehmen, dass Architekten häufig in der Mitte des Prozesses zu finden sind. Sie halten Kontakt zum Auftraggeber, Geschäftsführer, Entwickler, zu den Administratoren und Systemingerieren und zum Produktmanager. Er benötigt selbst Informationen von diesen Personen, und diese Personen benötigen INformationnen von him. Das macht klar, dass Kommunikationsstärke eine wichtie Voraussetzung ist.

Und dann git es eben noch den Architekten in Personalunion, der diese Aufgabe nur in Teilzeit ausführt und nebenbei noch entwickelt oder das Design der Software entwirft


Und dann gibt es eben noch den Architekten in ersonalunion, der diese Aufgabe nur in Teilzeit ausführt und nebenbei noch eintwickelt oder das Design der Software entwirft.

## Anforderungen

Anforderungen stehen am Anfang einer jeden Softwarearchitektur. Obgleich einleuchtend, sind die Anforderungen in der Praxis oft das schwächste Glied in der Kette. Warum?

- Oft werden die Anforderungen erst in einer viel späteren Phase des Projekts beschrieben
- Es ist nicht klar, welche Anforderungen Auswirkungen auf die Architektur haben
- Die Anforderungen sind qualitativ und/oder quantitativ einfach nicht ausreichend

Ich habe es schon mehrfach angesprochen: ohne Spezifikation kein Projekt. Ohne Anforderungen keine Softwarearchitektur. Worauf sollte die denn sonst auch aufbauen? Anforderungen können von allen Projektbeteiligten stammen. Wichtig ist nicht so seht, wer die Anforderung stellt, sondern ob es sich wirklich um eine Anforderung handelt.
Ein Wunsch wird also erst dann zur Anforderung geadelt, wenn er Teil einer Vereinbarung ist. Das zieht die Notwendigkeit nach sich, diese schriftlich zu erfassen. Über Anforderungen ist in diesem Buch an verschiedenen Stellen zu lesen, daher soll es hier nur um Anforderungen zum Zwecke der ARchitekturfindung gehen.

## Arten von Anforderungen

Zunächst unterscheiden wir zwischen

- funktionalen Anforderungen, also Anforderungen, die mit den Funcktionen einer Software zu tun haben, wir beispielsweise Berechnugnen, Abläufe oder die verwendeten Daten. Kurzum: Es geht darum, was eine SOftware tun soll.
- nicht-funktionalen Anforderungen: darunter fallen Anforderungen, die das System als solches qualitativ näher beschreiben. Sicherheit, Performance, Benutzerfreundlichkeit, Skalierbarkeit und Wartbarkeit fallen in diese Kategorie. Hier get es also darum, wie eine Software beschffen sein soll.

IN Projekten fehlen oft die nicht-funktionalen Anforderungen, und so entstehen manchmal Achitekturen, die am Kern einer Sache vorbeigehen. Scheinbar kleine Anmerkungen kännen die Welt verändern, wie z.B:

- Die Anbindung soll auch funktionieren, wenn das Zielsystem zeitweise nicht zur Verfügung steht.
- Die Daten sollen auch auf einem Notebook "mitgenommen" werden können
- Wir wollen die SOftare später beim Kunden erweitern können, beispielsweise durch separat lizenzierte Plugins

Die Schwierigkeit liegt oftmals darin, dass Anwender (oder Produktmanager) diese Anforderungen nicht explizit definieren. Meist wissen Sie gar nicht, welche Auswirkungn solche Anforderungen auf die Softwarearchitektur haben. Es wird also umso mehr Iher Aufgabe sein, diese Anfroderungen zu hinterfragen.

Oft geschieht das nicht, aus der Befürchtung heraus, Begehrlichkeiten zu wecken. Denn wer würde auf die Frage "Wie hoch soll denn die Verfügbarkeit sein?" nicht spontan antworten: "So hoch wie möglich, am besten 100%"? Bieten SIe doch verschiedene Optionen an, aus denen der Auftraggeber wählen kann, und versehen sie jehe Option mit einme Presschild.

Denken Sie einfach immer daran: Auch wenn eine SOftware alle funktionalen Anforderungen erfüllt, kann sie dennoch in der Praxis unbrauchbar sein. Was nützt shcon eine korrekt funktionierende Auftragserfassung, die nicht bedienbar ist, oder eine Software für die Terminbörse, die nicht mit der anfallenden Last zurechtkommt?

Nicht alle dieser nicht-funktionalen Anforderungen sind für jedes Projekt gleichermaßen wichtig. SIe können sich jedoch daran orientieren, wenn Sie möchten.

- Performance: escheribt möglichst harte Kennzahlen, beispielsweise: "Das System soll in der Lage sein, in SPitzenzeiten bis zu 1.000 Bestellungen in der Minute zu verarbeiten"
- Skalierbarkeit: Im obigen Beispiel war schon von Spitzenzeiten die Rede, ein Hinweis auf Skalierbarkeit. Ein weiteres Beispiel: "Die Software soll so erweiterbar sine, dass wir damit künftig unsere Wachstumsziele abbilden können" (die dann natürlich quantitativ erfasst sein müssen)
- Sicherheit: Definiert sicherheitsrelevant ANforderungen, zum Beispiel: "Die Komponente zur Verbindung mit unseren Zulieferern soll in einem abgesicherten Bereich ausgeführt werden mit speziellen Zugriffsrechten und ohne die Möglichkeit, auf andere Bereiche der Software zuzugreifen."
- Benutzerfreundlichkeit: HIer es ist mitunter schwierig, diese Merkmal messbar zu machen. Helfen können Usability-Tests. Eine mögliche Anforderung wäre dann: "Die Software soll ein durchschnittliche Benotung von 2.2 oder besser erreichen"
- Erweiterbarkeit: Eine ALLGEMEINE aUSSAGE GENÜGT HIER NICHT, DENN VON JEDER sOFTWARE kann erwartet werden, dass sie erweiterbar ist. Es geht mehr um spezielle Anforderungen wie: "Es is geplant, bis zum Jahresende underen Kunden drei neue Module zu verkaufen, die diese dann separat lizenzieren und installieren können"
- Kompatibilität: Ist dann wichtig, wenn die Software kpmpatibel zu einem System sein muss oder gar ein Testat benötigt wird. Beispiel: "Unsere Software muss der GDPdU-entsprechen" und "Der EXport muss Open XML-kompatible Dateien erstellen" Auch Anforderungen zur Interoperabilität können in diese Kategorie fallen. Oder aber es werden gesetzliche Anforderungen gestellt, beispielsweise wenn die Medizingeräteverordnung zur Anwendung kommt
- Robustheit : Die Aspekt wird oft in prozentualer Verfügbarkeit angegeben: "Es wird eine Verfügbarkeit von 99.3% zugesichert" Oft sind an solche Aussagen Support Level Agreement gebunden und/oder es wird eine bestimmte Wiederherstellungszeit gefordert
- Supportbarkeit: SOlche Anforderungen sind meist konkreter zu fassen, denn der Begriff an sich ist nicht sehr ergiebig. Beispiel: "Unser SUpport soll, auf Wunsch des Kunden, Zugriff auf alle Fehlermeldungen erhalten". IN diese Kategorie fallen auch Anforderungen zu Logging und Tracing
- DOkumentation: Besonders dann, wenn eine SOftware im Kundenauftrag erstellt wird, kann es für Art und Umfang der DOkumentation gewisse Anfroderungen geben: Beispiel: "Der AUftragnehmer erstellt für die fünf wichtigsten Prozesse Tutorials, mit einem Umfang zwischen 5-10 Seiten pro Tutorial"