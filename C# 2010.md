### Gute SOftware, Schlechte Software

VOr gut zehn Jahren hatte ich den ersten Kontakt mit einem damals neuartigen Online-CMS (Content Management System). Es war kurz vorher bei einem Unternehmen eingeführt worden, in dem ich als Leiter der Online-Entwicklung eingestellt wurde. Es stammte von einem renommierten Unternehmen, hatte einen klangvollen Namen, und die Verkäufer konnten mit einer langen Referenzliste worden. Meine Aufgabe sollte es sein, auf Basis dieses Systems zahlreiche neue ONline-Auftritte zu entwickeln, gemeinsam mit eigenne und freiberuflichen Mitarbeitern.

Für den Einkäufer dieses CMS war das eine sichere Sache, sollte man meinnen. IM praktischen Einsatz wurden sehr bald die Mängel deutlich, und die waren gravierend: Das System lahmte selbst auf den schnellsten Servern, es war instabil, ganz und gar kontra-intuitiv zu bedienen, schwer zu administrieren und mit allerlei eigenen, proprietären Lösungen für ganz alltägliche Probleme ausgesstattet.

Hotline, Entwicklung und Geschäftsleitung des Softwareherstellers hatten das Problem längst ausgemacht: Der Kunde sei das Problem, das System liefe schließlich in großen Installationen zuverlässig und, soweit man wisse, problemlos. Das wollte ich nicht recht glauben, und so begann ich, mit diesen Referenzkunden zu telefonieren und sie zu besuchen. Und wie es zu erwarten war, glichen sich die Probleme. Viele UNternehmen berichteten über genau die Schwierigkeiten, die auch wir hatten.

Und so war das Ende unausweichlich: Nach einigen erfolglosen Resleases tauschten wir das System gegen ein CMS aus, das aufff offenen Standards wir PHP und MySQL aufbaute, kaum ein Zwanzigstel so teuer und wenigstens zehnmal so schnell war. Dieses System läuft auch heute noch.

Seitdem habe ich mich in zahlreichen Projekten immer wieder gefragt: Was macht gute Software aus, und was unterscheidet sie von schlechter Software? Warum lässt sich die eine Software elegant und preiswer erweitern, während sich andere Programme vehement gegen jede Form der Anpassung sträuben? Warum gibt es Lösungen, mit denen sich flüssig arbeiten lässt, während bei anderen jeder Klick zum Geduldsspiel wird, und warum gibt es so viele gute Benutzeroberflächen, aber warum auch so viele schlechte? Wieso kann der Aufwand fürdas Customizing einen Brchteil des Kaufpreises ausmachen, aber auch leicht ein Mehrfaches, und warum müssen manche Softwareprodukte bei jedem neuen Release in großen Teilen neu geschrieben werden, während andere über viele Jahre hinweg scheinbar mühelos erweitert werden können?

#### Wege zur Lösung

Ich behaupte nicht, die Antwaort auf all diese Fragen zu kennen. Aber ich habe über die Jahre zahlreiche Muster entdeckt, Fallstricke, wenn Sie es so nennen möchten, aus den eigenen Projelkten heraus, aber vor allem in der Zusammenarbeit mit meinen Mitarbeitern, eexternen Programmierern, Auszubildenden und Consultants.  Aus meinen und ihren Erfahrungen ist dieses Buch entstanden. Es verfolgt 3 Ziele:

**Wissen erweitern**
Geradeich kleineren UNternehmne müssen Entwickler oft wahre Allrounder sein. Denn neben fundierten Fertigkeiten in verschiedenen Programmiersprachen benötigen Sie noch viele weitere Kenntnisse, beispielsweise in Fragen der Softwarearchitektur, im Softwaredesign, in ihrer Entwicklungsumgebung, in den verschiedensten eingesetzten Technologiesn, in Softwaretests, Projektmanagement und Datenbankentwurf.

NIch jeder Entwickler hat die Zeit, Lust oder Gelegenheit, sich durch viele Regalmeter Fachliteratur zu arbeiten. Dieses BUch macht den durchaus gewagten Versuch, die wichtigsten Bereiche der Softwareentwicklung in einem einzigen Werk zu behandeln, von der richtigen Architektur über die UMsetzung bis hin zur Softwarepflege nach deren Einführung. Damit ist es ein Buch für "Aufsteiger", also Entwichler, die dazulernen möchten und die über Bekanntes aus einem anderen BLickwinkel neu nachdenken wollen

**Problem vermeiden helfen**

In diese BUch finden SIe immer wieder Kästen mit dem Titel "Aus der Praxis". In diesen Kästen finden SIe das eine oder andere Problem, das ich inder Vergangenheit selbst erlebt habe, und meist einen Lösungsansatz dazu. Vielleicht erkennen SIe bisweilen Ihr eigenes Projekt darin wieder, dann betrachte ich SIe als Leidensgenossen, wenn Sie erlauben. Ansonsten täten Sie mir einen großen Gefallen, wenn Sie diese Problem vermeiden würden

Ich habe beim Schreiben bisweilen selbst gestaunt, wie viele Fehler mir während der Jahre unterlaufen sind. Viele wären leicht zu vermeiden gewesen, bei anderen lagen ihre Ursachen etwas tiefer

**Best Practices vermitteln**

Der Begriff *Best Practices* stammt eigentlich aus der Betribeswirtschaft und bezeichnet bewährte Verfahren, die sich für gleiche oder ähnliche Aufgabenstellungen eignen. *Entwurfsmuster* oder *Design Patterns* sind fertig Lösungen oder Lösungsschablonen für häufig widerkehrende Probleme in der Softwareentwichlung. SIe könne damit ebenfalls inm weiteren Sinne den Best Pracktices zugerechnet werden.

Myriaden von Problemen entstehen durch die falsche oder unzureichenede IMplementierung häufig wiederkehrender Aufgabenstellungen. Niht selten hat jeder Entwickler seine eigene Lösung entwickelt. Dabei sind viele dieser Aufgabenstellungen im Detail komplex, die Lösungen aber meist zu einfach,  wie das folgende Beispeil zeigt

´´´
    Um mit Services zu kommunizieren, die mit WCF (Windows COmmunication Foundation) entwickelt wurden, benötigt man einen Proxym, ein Objekt also, das die Kommunikation mit dem Service kapselt. In vielen Lehrbüchern findet man dazu Beispiele wie:
        MyServiceClient client = new MyServiceClient();
        client.Open();
        try
        {
            client.DoSomething();
        }
        catch (Exception ex)
        {
            MessageBox();
        }
        client.Close();
´´´

Dieses Beispeil funktioniert und ist daher in vielen Programmen verwirklicht. ES ist aber wenig praxistauglich, den Verbindungsabbrüche, Timeouts, SIcherheitsprobleme und einige andere aufgetretende Ausnahen verlangen nach jewielts speziellen Behandlungen. Das ist unverzichtbar für ein robustes und fehlertolerantes Programm.

IM Grunde genommen müsste sich nun jeder Entwickler in die Tiefen der WCF-Kommunikation begebenm, um selbst eine adäquate Lösung zu entwickeln, oder er greift auf das Client-Pattern in Kapitel 6, "Windows Communication FOundation", zurück.


# Das Fallbeispiel

An der einen oder anderen Stelle vewende ich ein Fallbeispeiel, gewissermaßen als Kontrastprogramm zu den allerorts beliebten "Hallo Welt!" Beispeielen. Herzlich willkommen also in der Welt der Kalimba Sunfood mb, dem Premium IMporteur für sonnenverwöhnte Früchte aus aller Welt mit Sitz in Hamburg.

Unsere Firma importiert Waren aus aller Welt und benötigt hierfür eine Enterprise Resource Planning Software zur Stererung aller betrieblichen Funktionen, also:
- Warenwirtschaft
- Kundenerwaltung
- Finanz und Rechnungswesen
- Verkauf und Marketing
- Controlling ung
- Personalwirtschaft

Es werden etwa 800 Mitarbeiter beschäftigt, die Hälfte am Stammsitz in Hamburg, die andere Hälfte verteilt auf mehrere Standorte weltweit. Kalimba Sunfood kauft die Früchte vor Ort ein, beispeielsweise Orangen aus Brasilien oder Mangos aus Indien, exportiert sie nach Deutschland und vertreibt sie dort an Großhändler und die Getränkeindustrie. Darüber hinaus betreibt die Gesellschaft einnen Onlineshop für Cocktail-Fruchtsäft, in dem Privatkunden direkt bestellen können.

Die beiden Niederlassungen in den USA und Indien sind bereitbandig an die Zentralle angeschlossen, ihre Mitarbeiter nutzen Rich-CLient-Anwendungen. Die Büros der Einkäufer sind schmalbandig ageschlossen, daher greifen die dortigen Mitarbeiter über das Internet auf Webanwendungen zu. Natürlich setzt die hausinterne Entwicklungsabteilung auf .NET als Kerntechnologie und dazu noch auf
- Winforms für die Rich-Client-Anwendungen
- ASP.NET für die Webanwendungen
- WCF für die serviceorientierte Mittelschicht
- WF für die Verarbeitung der Bestellungs-Workflows
- VS 2010 Premium als Entwicklungsumgebung und auf
- SQL server 2008 als Datenbanksystem
Das zu entwickelnde ERP-System nennt unsere Firma das Kalimba.ERP

# Architekturentwurf

EIn Kapitel üüber Softwarearchitektur in einem Praxis buch, passt das zusammen? Ja, wenn wir Softwarearchitektur als das verstehen, was sie ist - als notwendigee Grundlage für den Bau erfolgreicher Software

Architektur ist kein Selstzweck, und Architekturdiagramme sind nur selten etwas, für das derAuftraggeber bezahlen möchte. Der allseits bemühte Vergleich mit den Architekten im Bauwesen stellt klar: ohne Architekt kein Gebäude, ohne Softwarearchitekt kein Softwareprodukt. Ich meide solche Vergleiche jedoch, denn Bau und Softwarearchitekten haben nur wenig gemeinsam. Während es im Baugewerbe unzählige Regeln und Normen gibt, treffen wir in der SOftwareentwicklung, wenn überhaupt, auf Best Practices. Und wo sich die Bauvorhaben großteils ähneln, ist jede SOftware eine Einzelanfertigung. Mehr noch: Imgegensatz zum Bauarchitekten gibt es für Softwarearchitekten keine allgemein anerkannte und weitverbreitete Ausbildung, ja noch nicht einmal über deren Aufgaben besteht Einigkeit